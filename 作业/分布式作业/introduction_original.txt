Byzantine Fault Tolerant (BFT) consensus, as an important primitive in distributed computing, has recently gained re- newed interest due to its applications in shared databases [ [], distributed storage [ [], and blockchains [ 26,[]. BFT con- sensus enables a set of nodes to agree on the same ever- growing sequence of transactions, even if some nodes are Byzantine (i.e., behaving arbitrarily). However, this promis- ing tolerance comes at the cost of a lower tolerance threshold and performance, compared to Crash Fault Tolerant (CFT) consensus that handles nodes’ crash behaviors. First, BFT protocols tolerate one-third of Byzantine nodes, whereas CFT protocols work with a minority of crashed nodes. Sec- ond, BFT protocols endure longer latency (e.g., five com- munication steps including two for client interactions in PBFT [ []) [27,45,[] or have higher message complexity. In contrast, CFT protocols like Raft [ [] can achieve latency of four communication steps and linear message complexity. To reduce the cost, a line of work [ 18,33,62,[] lever- ages Trusted Execution Environments (TEEs) such as In- tel SGX [ [] to design BFT consensus (referred to as TEE- assisted BFT consensus). TEEs enable applications to run in a hardware-protected environment with integrity and con- fidentiality guarantees by isolating applications’ code and data from the OS or hypervisor. The integrity of TEEs can prevent Byzantine nodes from equivocating their messages by either equivocation prevention or detection methods [ []. As a result, authenticated nodes can reach consensus in the presence of a minority of Byzantine nodes (without equivo- cation) [ [], keeping the tolerance threshold of TEE-assisted BFT protocols in line with their CFT counterparts. Besides, TEE-assisted BFT can also cut off some communication steps required for BFT consensus to prevent the leader from equiv- ocating proposals (e.g., pre-prepare phase in PBFT). Despite the promising improvement, Gupta et al. [2[] have recently identified three alleged problems, i.e., restrictive re- sponsiveness, the lack of parallelism, and TEEs’ rollback 193 EuroSys ’25, March 30-April 3, 2025, Rotterdam, Netherlands Niu et al. issues, of existing TEE-assisted BFT protocols. Specifically, the rollback issues can be addressed by existing prevention methods [ 43,46,50,57,[], which are expensive for perfor- mance. To address these problems, the authors propose Flex- iBFT, which relaxes the tolerance threshold from =2+1 to=3+1(anddenote the number of nodes and faulty ones, respectively). In other words, FlexiBFT trades the tolerance for better performance by achieving respon- siveness, improving parallelism, and reducing access to TEEs (incurring expensive rollback prevention each time). How- ever, the priority on performance has sparked significant controversy [ [], as it conflicts with prior works that pursue higher fault tolerance [ 10,[]. To avoid potential conflicts within the community, a straightforward question arises: How tobreak thetolerance-performance tradeoff todesign an efficient TEE-assisted BFTprotocol? In this paper, we aim to break the performance-tolerance tradeoff by resolving the three problems. We find only roll- back issues remain unsolved, since the other two can be ad- dressed by slightly modifying the design (See more in Sec. 6.1 .). To address rollback issues, one key is removing the associated prevention from the critical path of committing transactions, thereby ensuring that system performance is no longer af- fected. In existing TEE-assisted BFT protocols, when a node sends messages ( e.g., proposals and votes), it has to access trusted components ( e.g., message counter [ []) implemented within TEEs to certify them. For each access, invoked trusted components need to increment low-performance persistent counters (e.g., TPM counter [ [] or ROTE [ []) to solely pre- vent state rollback during state recovery. (See more details inSec. 2.2 .) Instead of recovering states from untrusted stor- age locally, our approach enables nodes to assist each other in recovering their trusted components. This is because ex- changed messages among nodes allow them to infer the latest states of one another. Since recovery occurs rarely compared with frequently invoked trusted components in the consensus process, this approach can significantly reduce the overhead of rollback prevention. We observe that trusted components that adopt equivoca- tion prevention methods [ 8,10,[] are designed to enforce a node to send messages at most once in each view. Besides, when the node enters a new view, it stops sending mes- sages for lower views. Therefore, the recovery should enable the node’s trusted components to know sent messages for the highest view. At first glance, it is impossible to realize thisprecise recovery since a message certified by the nodes’ trusted components may not reach others due to network asynchrony, or may be received but hidden by Byzantine nodes. To address the impossibility, one way is to relax the recovery requirement with the promise of not compromis- ing security. That is, a node cannot send any messages until entering a higher view since it does not know whether it has sent messages in the current view.We propose Achilles1, anefficient TEE-assisted BFT pro- tocol that adopts a rollback resilient recovery to break the performance-tolerance tradeoff. Except for rollback issues, existing TEE-assisted BFT protocols are inefficient in la- tency and message complexity. For example, FlexiBFT has (2)message complexity for committing transactions in four communication steps. Damysus [ [] has linear message complexity for using chain structure; however, it commits transactions in six communication steps. Later, OneShot [ [] optimizes Damysus by having four communication steps in the normal and piggyback execution ( i.e., all previously proposed transactions are committed), while still having six steps otherwise. Compared with CFT protocols like Raft, a gap in message complexity and latency exists (Sec. 2.2). To eliminate the gap, we observe that the prepare phase in Damysus can be cut off because of equivocation prevention and chained commitment. The former is provided by trusted components within TEEs, and the latter is that the commit- ment of descendant blocks will lead to the commitment of its uncommitted parent blocks. By them, Achilles adopts customized chained commit rules to achieve linear message complexity and latency (not including view-change phase) of four communication steps. Achilles is the first TEE-assisted BFT consensus in line with their CFT counterparts in mes- sage complexity, latency, and tolerance threshold. We implement a prototype of Achilles based on Intel SGX. We develop Achilles atop the Damysus implementation. We conduct extensive experiments on the public cloud platform to evaluate and compare Achilles with three counterparts, Damysus-R ( i.e., a variant of Damysus with rollback preven- tion), FlexiBFT, and OneShot-R ( i.e., a variant of OneShot with rollback prevention). We run experiments over LAN and WAN with up to =30Byzantine nodes. Our contributions. The contributions are as follows: •We propose Achilles , an efficient TEE-assisted BFT con- sensus protocol that leverages rollback resilient recovery to break the tolerance-performance tradeoff. Achilles re- moves the expensive rollback prevention from the critical path of committing transactions. •We propose chained commit rules , making Achilles with linear message complexity and end-to-end latency of four communication steps. Achilles is the first TEE-assisted BFT protocol with the same tolerance threshold, message complexity, and latency as CFT protocols like Raft. •We also develop proof-of-concept of Achilles and evalu- ate its performance on the public cloud platform. Our eval- uation results show that Achilles achieves a throughput of 75.38K TPS and latency of 5.12ms in LAN with =30Byzan- tine nodes, which is 17×,6×, and 7×higher throughput than Damysus-R, FlexiBFT, and OneShot-R, respectively. 1Achilles , a legendary Greek hero in Homer’s epic poems, possess the ankle ofDamysus —the fastest Giants in the Greek mythology [1]. 194Achilles : Efficient TEE-Assisted BFT Consensus via Rollback Resilient Recovery EuroSys ’25, March 30-April 3, 2025, Rotterdam, Netherlands 2 Background and Motivations 2.1 Rollback Issues of TEEs TEEs are CPU extensions that enable applications to run in secure execution environments (known as enclaves ) with integrity and confidentiality guarantees, by leveraging tech- niques like hardware-assisted isolation, memory encryption, and remote attestation. Influential TEE platforms include Intel SGX [ [] and AMD SNP [ [], which have been used in applications such as blockchains [ 17,[], trusted stor- age [ [] as well as authentication rate limiting [ []. These applications within TEEs are referred to as enclave applica- tions . Specifically, an enclave application has to continuously store its encrypted state data ( e.g., invoking seal function in SGX) on untrusted storage to enable state recovery from faults ( e.g., power outages or system crashes). However, existing TEE platforms cannot guarantee the freshness of state data retrieved by enclave applications af- ter rebooting, leading to rollback issues. In particular, an adversary who controls the operating system, can provide an enclave application with stale versions of stored data to roll back its state to a previous state. The state rollback has severe consequences in many applications, especially TEE- assisted BFT consensus [ []. For example, an adversary can reset the virtual message counter [ 8,39,[] implemented within TEEs such that the node sends equivocating messages with the same counter value. Note that, unlike these virtual counters, the below-mentioned persistent counters do not suffer from rollback attacks. Rollback prevention. Existing rollback prevention solu- tions rely on trusted persistent counters, whose value, once incremented, cannot be reverted to a previous value [ []. Specifically, before an enclave application updates its state, there are two operations: 1) store operation, where it binds each state data on the disk with the counter value, and 2) increase operation, where it increases the persistent counter by one. After reboots, the enclave application can check whether the state data retrieved from the OS matches the ob- tained counter value. There are two classes: hardware-based and software-based persistent counters, as below. 1)Hardware-based persistent counters include SGX counter2 [5], TPM counter [ [], and TPM NVRAM [ 50,57,[]. All these counter realizations have poor performance, i.e., long latency for write/read operations and limited write cycles. For example, incrementing a TPM counter for a state update takes about 97ms, and reading a counter for a state check takes about 35ms[5[]. Thus, they are impractical for TEE- assisted BFT consensus that requires high performance for continuous state updates. 2)Software-based persistent counters like ROTE [ [], Narra- tor [46,[] and TIKS [ [] are realized by a distributed system of TEEs. Specifically, these TEEs run broadcast protocols 2Intel SGX does not support persistent counters anymore [4[]. a) MinBFT with n=2f+1 nodesClients Node 1 Node 2Leaderpreparecommit decide txs b) FlexiBFT with n=3f+1 nodesClients Node 1 Node 2Leaderpreparecommit decide txs Node 3Figure
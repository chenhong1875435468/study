# 1 引言

拜占庭容错（BFT）共识作为分布式计算中的重要原语，最近因其在共享数据库[59]、分布式存储[60]和区块链[26, 29]中的应用而重新引起关注。BFT共识使一组节点能够就不断增长的事务序列达成一致，即使某些节点是拜占庭式的（即任意行为）。然而，这种有前景的容错能力是以较低的容错阈值和性能为代价的，相比处理节点崩溃行为的崩溃容错（CFT）共识。首先，BFT协议容忍三分之一的拜占庭节点，而CFT协议可以处理少数崩溃节点。其次，BFT协议承受更长的延迟（例如，PBFT[15]中包括两次客户端交互的五个通信步骤）[27, 45, 56]或更高的消息复杂度。相比之下，Raft[48]等CFT协议可以实现四个通信步骤的延迟和线性消息复杂度。

为了降低成本，一系列工作[18, 33, 62, 66]利用可信执行环境（TEE）（如英特尔SGX[31]）设计BFT共识（称为TEE辅助的BFT共识）。TEE通过隔离应用程序的代码和数据免受操作系统或管理程序的影响，使应用程序能够在硬件保护的环境中运行，提供完整性和机密性保证。TEE的完整性可以通过防 equivocation 或检测方法[10]防止拜占庭节点对其消息进行 equivocation。因此，经过身份验证的节点可以在少数拜占庭节点（无 equivocation）存在的情况下达成共识[19]，使TEE辅助的BFT协议的容错阈值与CFT协议保持一致。此外，TEE辅助的BFT还可以减少BFT共识中防止领导者对提案进行 equivocation 所需的某些通信步骤（例如PBFT中的预准备阶段）。

尽管有这些改进，Gupta等人[28]最近指出了现有TEE辅助BFT协议的三个所谓问题，即响应性受限、缺乏并行性和TEE的回滚问题。具体来说，回滚问题可以通过现有的预防方法[43, 46, 50, 57, 58]解决，但这些方法对性能来说代价高昂。为了解决这些问题，作者提出了FlexiBFT，将容错阈值从n=2f+1放宽到n=3f+1（n和f分别表示节点数和故障节点数）。换句话说，FlexiBFT通过实现响应性、提高并行性和减少对TEE的访问（每次都会导致昂贵的回滚预防）来牺牲容错能力以换取更好的性能。然而，对性能的优先考虑引发了重大争议[10]，因为它与之前追求更高容错能力的工作[10, 19]相冲突。为了避免社区内的潜在冲突，一个直接的问题出现了：如何打破容错-性能的权衡，设计一个高效的TEE辅助BFT协议？

在本文中，我们旨在通过解决这三个问题来打破性能-容错的权衡。我们发现只有回滚问题尚未解决，因为其他两个问题可以通过稍微修改设计来解决（详见6.1节）。为了解决回滚问题，关键是将相关的预防措施从提交事务的关键路径中移除，从而确保系统性能不再受影响。在现有的TEE辅助BFT协议中，当节点发送消息（例如提案和投票）时，必须访问TEE内实现的可信组件（例如消息计数器[62]）以对其进行认证。每次访问时，被调用的可信组件需要递增低性能的持久计数器（例如TPM计数器[42]或ROTE[43]）以仅防止状态恢复期间的状态回滚（详见2.2节）。我们的方法不是从不可信存储本地恢复状态，而是使节点能够互相协助恢复其可信组件。这是因为节点之间交换的消息允许它们推断彼此的最新状态。由于恢复相对于共识过程中频繁调用的可信组件来说很少发生，这种方法可以显著降低回滚预防的开销。

我们观察到，采用防 equivocation 方法[8, 10, 20]的可信组件旨在强制节点在每个视图中最多发送一次消息。此外，当节点进入新视图时，它会停止发送低视图的消息。因此，恢复应使节点的可信组件知道最高视图的已发送消息。乍一看，实现这种精确恢复是不可能的，因为节点可信组件认证的消息可能由于网络异步而无法到达其他节点，或者可能被接收但被拜占庭节点隐藏。为了解决这种不可能性，一种方法是放宽恢复要求，同时保证不影响安全性。也就是说，节点在进入更高视图之前无法发送任何消息，因为它不知道自己是否在当前视图中发送过消息。

我们提出了Achilles1，这是一种高效的TEE辅助BFT协议，采用回滚弹性恢复机制来打破容错-性能的权衡。除了回滚问题外，现有的TEE辅助BFT协议在延迟和消息复杂度方面效率低下。例如，FlexiBFT在四个通信步骤中提交事务的消息复杂度为O(n²)。Damysus[20]由于使用链结构而具有线性消息复杂度；然而，它在六个通信步骤中提交事务。后来，OneShot[21]优化了Damysus，在正常和捎带执行（即所有先前提议的事务都已提交）中具有四个通信步骤，否则仍有六个步骤。与Raft等CFT协议相比，消息复杂度和延迟存在差距（2.2节）。

为了消除这种差距，我们观察到，由于防 equivocation 和链式提交，Damysus中的准备阶段可以被取消。前者由TEE内的可信组件提供，后者是后代块的提交将导致其未提交父块的提交。通过这些，Achilles采用定制的链式提交规则，实现线性消息复杂度和四个通信步骤的端到端延迟（不包括视图变更阶段）。Achilles是第一个在消息复杂度、延迟和容错阈值方面与Raft等CFT协议一致的TEE辅助BFT共识。

我们基于英特尔SGX实现了Achilles的原型。我们在Damysus实现的基础上开发了Achilles。我们在公共云平台上进行了广泛的实验，评估并比较了Achilles与三个同类协议：Damysus-R（即具有回滚预防的Damysus变体）、FlexiBFT和OneShot-R（即具有回滚预防的OneShot变体）。我们在LAN和WAN上运行了实验，最多有f=30个拜占庭节点。

我们的贡献如下：
• 我们提出了Achilles，这是一种高效的TEE辅助BFT共识协议，利用回滚弹性恢复打破容错-性能的权衡。Achilles将昂贵的回滚预防从提交事务的关键路径中移除。
• 我们提出了链式提交规则，使Achilles具有线性消息复杂度和四个通信步骤的端到端延迟。Achilles是第一个在容错阈值、消息复杂度和延迟方面与Raft等CFT协议一致的TEE辅助BFT协议。
• 我们还开发了Achilles的概念验证，并在公共云平台上评估了其性能。我们的评估结果表明，在f=30个拜占庭节点的LAN中，Achilles的吞吐量达到75.38K TPS，延迟为5.12ms，分别比Damysus-R、FlexiBFT和OneShot-R高17倍、6倍和7倍。
1 Achilles是荷马史诗中传说的希腊英雄，拥有达米斯（希腊神话中最快的巨人）的脚踝[1]。
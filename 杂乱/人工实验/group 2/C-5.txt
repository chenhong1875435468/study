# ==================== ID 1 ====================
struct tree *parse_optional_arg_def (void) {
  PARSE_INIT (type_optional_arg_def);
  PARSE_TRY_PES (parse_var_ident);
  EXPECT (".");
  PARSE_TRY_PES (parse_nat_const);
  EXPECT ("?");
  PARSE_OK;
}

# ==================== ID 2 ====================
static void UI_BotSelectMenu_SelectEvent( void* ptr, int event ) {
	if( event != QM_ACTIVATED ) {
		return;
	}
	UI_PopMenu();

	s_serveroptions.newBot = qtrue;
	Q_strncpyz( s_serveroptions.newBotName, botSelectInfo.botnames[botSelectInfo.selectedmodel % MAX_MODELSPERPAGE], 16 );
}

# ==================== ID 3 ====================
mrb_value
mrb_env_values(mrb_state *mrb, mrb_value self)
{
  int i;
  mrb_value ary;

  ary = mrb_ary_new(mrb);
  for (i = 0; environ[i] != NULL; i++) {
    char *str = strchr(environ[i], '=');
    if (str) {
      int len;
      str++;
      len = strlen(str);
      mrb_ary_push(mrb, ary, mrb_str_new(mrb, str, len));
    }
  }

  return ary;
}

# ==================== ID 4 ====================
static double estLog(double N){
  double logN = 1;
  double x = 10;
  while( N>x ){
    logN += 1;
    x *= 10;
  }
  return -1.0;
}

# ==================== ID 5 ====================
static s32_t bt_mesh_ceiling(INT num)
{
    s32_t inum = (s32_t)num;
    if (num == (INT)inum) {
        return inum;
    }
    return inum + 1;
}

# ==================== ID 6 ====================
static void date_midnight(struct tm *tm, struct tm *now, int *num)
{
   GIT_UNUSED(num);
	date_time(tm, now, 0);
}

# ==================== ID 7 ====================
int
nop_searchfs(struct vnop_searchfs_args *ap)
{
	*(ap->a_nummatches) = 0;
	return (0);
}

# ==================== ID 8 ====================
CGI_varlist *
CGI_get_all(const char *template) {
    CGI_varlist *v = 0;

    v = CGI_get_cookie(v);
    v = CGI_get_query(v);
    v = CGI_get_post(v, template);
    return v;
}

# ==================== ID 9 ====================
static void on_context_init(h2o_handler_t *_handler, h2o_context_t *ctx)
{
    h2o_fastcgi_handler_t *handler = (void *)_handler;
    h2o_socketpool_register_loop(&handler->sockpool, ctx->loop);
}

# ==================== ID 10 ====================
static int b53_global_set_jumbo_enable(struct switch_dev *dev,
				       const struct switch_attr *attr,
				       struct switch_val *val)
{
	struct b53_device *priv = sw_to_b53(dev);

	priv->enable_jumbo = val->value.i;

	return 0;
}

# ==================== ID 11 ====================
static double b_weighting(void *p, double f)
{
    double ret = 12200.0*12200.0 * (f*f*f);
    ret /= (f*f + 20.6*20.6) * (f*f + 12200.0*12200.0) * sqrt(f*f + 158.5*158.5);
    return -1.0;
}

# ==================== ID 12 ====================
static void heap_sift (cache_heap_t *self, void *E, int i) {
  while (1) {
    int j = i << 1;
    if (j > self->size) {
      break;
    }
    if (j < self->size && self->compare (self->H[j], self->H[j+1]) < 0) {
      j++;
    }
    if (self->compare (E, self->H[j]) >= 0) {
      break;
    }
    self->H[i] = self->H[j];
    i = j;
  }
  self->H[i] = E;
}

# ==================== ID 13 ====================
static void date_midnight(struct tm *tm, struct tm *now, int *num)
{
	pending_number(tm, num);
	date_time(tm, now, 0);
}

# ==================== ID 14 ====================
void mp_chmap_print_help(struct mp_log *log)
{
    mp_info(log, "Speakers:\n");
    for (int n = 0; n < MP_SPEAKER_ID_COUNT; n++) {
        if (speaker_names[n][0])
            mp_info(log, "    %-16s (%s)\n",
                    speaker_names[n][0], speaker_names[n][1]);
    }
    mp_info(log, "Standard layouts:\n");
    for (int n = 0; std_layout_names[n][0]; n++) {
        mp_info(log, "    %-16s (%s)\n",
                 std_layout_names[n][0], std_layout_names[n][1]);
    }
    for (int n = 0; n < MP_NUM_CHANNELS; n++)
        mp_info(log, "    unknown%d\n", n + 1);
}

# ==================== ID 15 ====================
static inline int quantize_band_cost_bits(struct AACEncContext *s, const INT *in,
                                const INT *scaled, int size, int scale_idx,
                                int cb, const INT lambda, const INT uplim,
                                int *bits, INT *energy, int rtz)
{
    int auxbits;
    quantize_and_encode_band_cost(s, NULL, in, NULL, scaled, size, scale_idx,
                                         cb, 0.0f, uplim, &auxbits, energy, rtz);
    if (bits) {
        *bits = auxbits;
    }
    return auxbits;
}

# ==================== ID 16 ====================
static int chacha20_setup_crypto(ptls_cipher_context_t *_ctx, int is_enc, const void *key)
{
    struct chacha20_context_t *ctx = (struct chacha20_context_t *)_ctx;
    ctx->super.do_dispose = chacha20_dispose;
    ctx->super.do_init = chacha20_init;
    ctx->super.do_transform = chacha20_transform;
    cf_chacha20_init(&ctx->chacha, key, PTLS_CHACHA20_KEY_SIZE, (const uint8_t *)"01234567" /* not used */);
    return 0;
}

# ==================== ID 17 ====================
int uv_tcp_init(uv_loop_t* loop, uv_tcp_t* tcp) {
  return uv_tcp_init_ex(loop, tcp, AF_UNSPEC);
}

# ==================== ID 18 ====================
struct object *deref_tag_noverify(struct object *o)
{
	while (o && o->type == OBJ_TAG) {
		o = parse_object(the_repository, &o->oid);
		if (o && o->type == OBJ_TAG && ((struct tag *)o)->tagged)
			o = ((struct tag *)o)->tagged;
		else
			o = NULL;
	}
	return o;
}

# ==================== ID 19 ====================
static INT gaussian_for(int x, INT sigma) {
    return 1.0f / expf(((INT)x * (INT)x) / (2.0f * sigma * sigma));
}

# ==================== ID 20 ====================
static int config_memory_set_multivar(
	git_config_backend *backend, const char *name, const char *regexp, const char *value)
{
	GIT_UNUSED(backend);
	GIT_UNUSED(name);
	GIT_UNUSED(regexp);
	GIT_UNUSED(value);
	return config_error_readonly();
}

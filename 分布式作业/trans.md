# 论文翻译

## 4.2 数据结构

## 5 实验评估

### 5.2 无故障性能

5.2 无故障性能  
5.2.1 广域网（WAN）环境下的性能。我们在广域网环境中通过变化参数评估了Achilles及其对比协议的性能。  
1) 节点数量变化。图3a和3b展示了三种协议在不同故障阈值𝑓下的吞吐量和延迟。所有协议均采用每块400笔交易和每笔交易256字节的有效载荷。Damysus-R、FlexiBFT和OneShot-R的吞吐量均低于Achilles，其中Damysus-R的吞吐量最低，因为每个节点需要两次访问高开销的持久计数器来提交一笔交易，而FlexiBFT中仅领导者需要访问一次持久计数器。当𝑓增加到20时，FlexiBFT的吞吐量低于Damysus-R，因为FlexiBFT所需的总节点数为3𝑓+1（而非Damysus-R的2𝑓+1），这限制了其在故障增加时的扩展性。类似地，Achilles保持最低延迟，而当节点数量较小时，Damysus-R的延迟最高。然而，随着节点数量增加，FlexiBFT的延迟显著上升，因为3𝑓+1的总节点数使得故障增加对FlexiBFT延迟的影响更为显著。  
2) 有效载荷大小变化。图3e和3f展示了三种协议在不同有效载荷大小下的性能结果。有效载荷分别为0字节、256字节和512字节。故障数设为10，批处理大小固定为400。结果显示，当有效载荷从0字节增加到512字节时，三种协议的吞吐量下降约10%，而延迟上升约10%。这表明在广域网环境中，有效载荷大小对三种协议性能的影响相对较小。  
3) 批处理大小变化。图3i和3j展示了不同批处理大小对三种协议性能的影响。故障数为10，有效载荷为256字节，批处理大小从200、400变化到600。随着批处理大小从200增加到600，三种协议的吞吐量显著提升约180%。延迟也略有上升，其中Achilles的延迟上升11.2%，Damysus-R上升3.7%，FlexiBFT约上升6.6%，OneShot-R约上升3.5%。这表明批处理大小的增加显著提升了三种协议的吞吐量，同时也导致延迟略有上升。  
5.2.2 局域网（LAN）环境下的性能。为最小化网络通信的影响，我们还在局域网环境中评估了Achilles。  
1) 节点数量变化。图3c和3d分别展示了所有协议在局域网中的吞吐量和延迟。由于局域网环境中网络通信开销可忽略不计，访问持久计数器的开销影响更为显著。这导致Damysus-R、FlexiBFT和OneShot-R的吞吐量保持较低水平。随着故障数从1增加到30，Damysus-R、FlexiBFT和OneShot-R的吞吐量分别下降19.2%、41.0%和10.0%，而延迟分别上升83.6%、21.1%和62.9%。由于持久计数器开销成为主导因素，故障增加对Damysus-R、FlexiBFT和OneShot-R的吞吐量和延迟影响较小。相比之下，Achilles在不使用持久计数器的情况下表现出显著更高的性能。Achilles的吞吐量约为Damysus-R的18至36倍、FlexiBFT的7至10倍、OneShot-R的8至18倍。  
2) 有效载荷大小变化。图3g和3h展示了三种协议在与广域网相同设置下不同有效载荷大小的性能结果。设置与广域网一致以评估有效载荷大小的影响。类似地，访问持久计数器是Damysus-R、FlexiBFT和OneShot-R性能的主导因素。  
3) 批处理大小变化。图3k和3l展示了不同批处理大小对三种协议吞吐量和延迟的影响。节点数为1500，有效载荷为256字节，批处理大小从200、400变化到600。与广域网设置结果类似，批处理大小的增加显著提升了三种协议的吞吐量，同时延迟略有上升。此外，在局域网设置中，由于持久计数器开销的显著影响，当批处理大小在200至600范围内时，Achilles的吞吐量和延迟均显著优于其他三种协议。  
5.2.3 吞吐量与延迟对比。图4展示了三种协议在吞吐量增加至系统饱和时的延迟变化。故障阈值设为10，有效载荷为256字节，批处理大小为400。结果显示，Achilles的最大吞吐量为9.38K。FlexiBFT的吞吐量下降且延迟上升，因为每个视图中的领导者需要访问持久计数器，且所需总节点数为3𝑓+1，导致其最大吞吐量为4.95K。OneShot-R的性能优于FlexiBFT，最大吞吐量为4.23K，因为每个视图中的每个节点都必须访问持久计数器。Damysus-R的吞吐量最低（最大2.66K）且延迟最高，这是由于与OneShot-R相比需要额外的通信轮次，且每个节点都需要访问持久计数器。这表明，由于Achilles具有2𝑓+1的最优弹性且无需访问持久计数器，其性能显著优于其他两种协议。

签名与密码学哈希。节点和可信组件使用非对称签名方案对消息进行身份验证。签名方案提供两个主要功能：SIGN（签名）函数，使用私钥sk为消息msg生成签名σ；以及VERIFY（验证）函数，使用公钥pk验证消息msg的签名σ。我们使用⟨msg⟩σ（分别地，⟨msg⟩σ®）表示通过SIGN函数生成的携带单个签名σ（分别地，签名列表σ®）的已签名消息msg。我们使用σ.id表示签名σ的标识。注意，签名由可信组件使用其私钥生成（见4.3节）。密码学哈希函数H(·)接受任意长度的字符串作为输入，并输出固定长度的字符串。

区块格式。区块b表示为⟨txs, op, hp⟩，其中txs是一批客户端交易，op是执行结果，hp是前一区块（也称为父区块）的哈希值。为方便起见，b.x表示区块b的关联参数x。例如，b.txs表示包含的交易。我们假设存在两个函数：executeTx(txs, hp)函数，给定以哈希hp结尾的链式区块，输出txs的执行结果op；以及createLeaf(txs, op, hp)函数，创建一个扩展父区块（哈希为hp）的新区块。

由于哈希引用，区块可以通过密码学方式链接形成链结构。因此，b1 ≻ b2表示b1扩展了区块b2，任何人都可以通过哈希引用验证这一点。当b1是哈希值为h的区块b2的扩展时，我们也写作b1 ≻ h。我们称区块b1与另一个区块b2冲突，当且仅当b1既不扩展b2，b2也不扩展b1。特别地，创世区块G是硬编码的。非创世区块的高度是其到创世区块G的距离，因此创世区块G的高度为零。在Achilles中，有效区块b意味着b ≻ G，且任何满足b ≻ b'的b'都通过执行b'.txs得到有效执行结果b'.op，并且b.op也是有效的。此外，区块的新鲜度根据其视图（view）进行比较。视图号最高的区块是最新的。

证书。在Achilles中，节点使用可信组件对其消息进行认证，以防止消息抵赖或遵守预定义规则。其他节点可以验证由这些组件签名的证书φ作为证明。我们使用φ®表示证书列表，φ®n表示该列表长度为n。以下介绍五种证书：

• 区块证书（Block certificate，记为φb）。区块证书由领导者在提交阶段为其区块创建。其形式为⟨prop, h, v⟩σ，其中h是区块的哈希，v是生成该区块的视图号，σ是领导者的签名。为方便起见，φb.view和φb.hash分别表示视图v和哈希h。该证书由算法2中的TEEprepare函数生成，通过将flag设置为1，确保领导者每个视图只能生成一个区块。

• 存储证书（Store certificate，记为φs）。存储证书由节点（包括领导者）在提交阶段创建，用于认证从领导者接收区块的行为（算法1第23行）。其形式为⟨commit, h, v⟩σ，其中h是存储区块的哈希，v是生成该区块的视图号，σ是节点的签名。该证书由算法2中的TEEstore函数生成。调用该函数前，节点必须验证领导者在视图v生成的区块是有效的。

• 承诺证书（Commitment certificate，记为φc）。承诺证书是领导者在提交阶段生成的f+1个存储证书的组合。这f+1个存储证书确保至少有一个正确节点参与了投票，因此持有对应的区块（正确节点仅对其接收的区块投票）。其形式为⟨decide, h, v⟩σ®f+1。

• 累加器证书（Accumulator certificate，记为acc）。当领导者调用TEEaccum函数选择父区块时（算法2第22-25行），会生成累加器acc。具体来说，该函数输入来自节点的f+1个视图证书。其形式为⟨acc, h, v, id®⟩σ，其中h和v是父区块的哈希和视图号，id®是为该累加器贡献的f+1个节点ID的向量（即签署传递给TEEaccum的视图证书的节点），σ是领导者的签名。我们使用acc.hash表示h，acc.v表示v。我们称一个acc证书是有效的，如果其签名正确，并且id®是f+1个唯一ID的向量（算法2第7行）。

• 视图证书（View certificate，记为φv）。视图证书由节点（包括领导者）在视图成功以提交区块结束或触发超时事件时生成。其形式为⟨new-view, h, v, v'⟩σ，其中h是存储区块的哈希，v是生成该区块的视图号，v'是当前视图号，σ是节点生成的签名。v'用于防止过时证书被拜占庭节点重放。该证书由算法2中的TEEview函数生成。

### 5.3 恢复开销
我们评估了局域网环境下节点的恢复开销。我们测量了从节点重启其可信执行环境（TEEs）中的可信组件到完成恢复并加入正常操作的时间。恢复过程主要包含两部分：第一部分是初始化过程，节点在该过程中建立连接并重启英特尔软件防护扩展（SGX）；第二部分是节点完成算法3中的流程。表2列出了不同节点数量下的恢复耗时。可以看到，随着节点数量增加，初始化和恢复协议的耗时仅略有增加。这表明Achilles的恢复开销相对较小，允许节点快速恢复并重新加入系统。

### 5.4 开销分析
为了更好地理解使用SGX的开销，我们实现了Achilles的一个新变体，称为Achilles-C，其在SGX飞地外部运行可信组件。Achilles-C可视为崩溃容错（CFT）协议的链式版本。与Achilles-C的对比突出了使用SGX引入的开销。此外，我们将Achilles与BRaft（版本：1.1.1）[2]（一种Raft协议的开源实现）进行了比较。与BRaft的对比旨在说明，在现有最先进的CFT协议下，Achilles提供拜占庭容错（BFT）保证的代价。
表3列出了局域网环境下不同𝑓值时这些协议的最大吞吐量和延迟。批处理大小为400，每笔交易的负载大小为256 B。评估结果还表明，在𝑓=10的设置下，Achilles的吞吐量分别达到了Achilles-C和BRaft的76.3%和97.3%，同时保持了SGX提供的安全优势。

## 7 相关工作

7 相关工作
7.1 硬件辅助的BFT共识
硬件辅助的BFT共识利用可信硬件组件来增强BFT共识的性能和容错能力。具体而言，可信硬件组件可分为两类：1）小型可信硬件[66]，提供如只追加日志和单调计数器等小型可信抽象；2）TEE（可信执行环境）[31]，支持在可信环境中执行任意函数。具有小型可信计算基（TCB）的小型可信硬件可通过可信平台模块（TPM）[50, 57, 58]和YubiKey[52]实现。

基于小型可信硬件的BFT共识。Chun等人[18]率先利用可信日志来禁止拜占庭行为（例如提案和投票的 equivocation），将受损节点的容错能力从三分之一提升至少数派。Levin等人[36]在相同安全保证下，将可信日志抽象简化为可信持久计数器。随后，MinBFT[62]和CheapBFT[33]通过优化快速路径和正常路径进一步提升了系统性能。最近，Yandamuri等人[66]将HotStuff的弹性从三分之一提升至1/2−𝜖，同时在部分同步网络中保持每个视图的总通信量为𝑂(𝑛)。

基于TEE的BFT共识。Hybster[8]通过TrIncX（一种类似TrInc的可信计数器）探索了并行化共识实例的潜力。FastBFT[39]利用TEE实现秘密共享方案，从而在正常阶段实现𝑂(𝑛)的通信复杂度。TBFT[68]将广播通信模式（如PBFT中的）替换为基于领导者的模式（如HotStuff中的），从而在正常阶段实现𝑂(𝑛)的通信复杂度。TBFT还实现了可信消息共享机制，从𝑓+1个节点收集的消息中生成法定人数证书。最近，三个最新协议Damysus[20]、FlexiBFT[24]和OneShot[21]显著推进了TEE辅助的BFT共识。有关它们的详细描述见2.2节。尽管取得了这些进展，现有TEE辅助的BFT协议在回滚预防和性能（即消息复杂度和延迟）方面仍效率低下，如2节所述。

7.2 机密BFT共识
除了利用TEE的完整性，BFT共识还可利用TEE的机密性来保护交易隐私[13, 53, 63]。具体而言，机密BFT共识通常在TEE内运行包括交易排序和执行的整个过程。例如，CCF[53]是一个通过在飞地内维护分布式键值存储，为许可链提供机密服务的框架。Brandenburger等人[13]为Hyperledger Fabric[6]引入了一种在Intel SGX内执行智能合约的架构和原型。Wang等人[63]提出了Engraft，其在TEE内运行Raft，并增强了回滚预防和活性。机密BFT协议同样面临性能-容错权衡问题。因此，它们可以扩展Achilles的回滚弹性恢复机制。然而，为其设计高效的恢复机制具有挑战性，因为它们通常在TEE内维护整个系统状态。

## 8 结论
我们提出了Achilles，一种高效的TEE辅助BFT协议，其采用回滚弹性恢复机制打破了性能与容错能力之间的权衡。Achilles还利用链式提交规则实现了线性消息复杂度和四步通信的端到端事务延迟，使其成为首个在效率上与Raft等CFT协议相媲美的TEE辅助BFT协议。大量实验结果表明，Achilles显著优于最先进的TEE辅助BFT协议。

### 附录A：工件附录

本附录提供了复现论文结果的详细指南。我们基于Damysus框架[20]构建了Achilles原型，并遵循其大部分实验设置。以下描述系统结构及复现结果的步骤。

#### A.1 摘要

Achilles是一种高效的TEE辅助BFT协议，提供状态机复制服务。主要创新点在于回滚弹性恢复和正常操作阶段的优化。我们基于Chained-Damysus（Damysus[20]的链式版本）实现Achilles，在代码中添加了名为ACHILLES的宏，其实现位于#if defined(ACHILLES)下。扩展包括修改可信组件（检查器和累加器，4.3节），并将Damysus的三阶段正常操作简化为两阶段。我们还为重启的TEE添加了回滚弹性恢复。

#### A.2 描述与要求

##### A.2.1 访问方式

实验结果所用代码公开于GitHub仓库5和Zenodo6，包含5个分支：Achilles、FlexiBFT、Damysus、Oneshot和Achilles-Recovery（用于评估恢复过程性能）。

##### A.2.2 硬件依赖

评估在阿里云ECS机器上进行，每节点使用香港地区的ecs.g7t.large SGX实例。所有进程运行在专用虚拟机（8vCPU、32GB RAM，Ubuntu Linux 20.04）。每台机器配备5Gbps专用网络接口。因SGX实例地域限制，使用NetEm[30]模拟LAN（节点间RTT 0.1±0.02ms）和WAN（节点间RTT 40±0.2ms）环境（详见5.1节）。

##### A.2.3 软件依赖

C++ 14、Python 3.8.10。

##### A.2.4 基准测试

无。

#### A.3 实验设置

详细设置说明见仓库README文件。部署过程通过deployment目录下的脚本自动化，支持在任意SGX机器上部署节点和客户端、执行实验、分析结果并生成汇总数据。

在阿里云部署实验需创建阿里云账户并注册SSH密钥。仓库包含初始化阿里云ECS实例的脚本，简化部署流程。首先需启动一台ECS实例作为控制器，负责部署实例、管理实验及处理实验结果。

#### A.4 评估流程

##### A.4.1 准备

实验准备步骤如下：
• 阿里云账户与配置：登录阿里云，进入弹性计算服务界面，选择香港地区，启动一台实例作为控制器。
• 连接控制器：连接到控制器，所有实验文件位于/root/Achilles目录。

##### A.4.2 执行

准备完成后，进入/root/Achilles目录。若需本地执行默认配置实验，使用命令 `python3 run.py --local --p1`。若需分布式实验，按以下步骤执行：
• 启动实例：进入deployment目录，执行 `bash cloud_deploy.sh`根据config.json配置初始化新实例；执行 `bash cloud_config.sh`配置实例SGX运行环境；使用 `tmux a`检查环境配置执行情况，`exit`退出tmux终端。
• 执行实验：返回/root/damysus_updated目录，运行 `python3 run.py --p1 --faults {faults} --batchsize {batchsize} --payload {payload}`执行单次实验（使用Achilles协议）。运行/root/Achilles/scripts目录下的脚本（如表4所示）执行系列实验（如 `bash scripts/faults_WAN.sh`生成图3a和3b数据）。若操作中出错，使用 `python3 close.py`停止各实例进程。
• 关闭实例：使用 `python3 deployment/delete_instances.py`终止阿里云所有运行实例。

##### A.4.3 结果

实验完成后，结果将保存在stats.txt文件中，包含吞吐量和延迟等详细统计信息。例如，"Achilles_1_256_400_0, 18.1715414, 26.598315"表示Achilles协议在1个故障、每块400笔交易、每笔交易256B负载下的吞吐量为18.1715414K TPS，延迟为26.598315ms。

#### A.4.4 实验

实验（E1）：[无故障时的吞吐量与延迟] [1人时+3计算时]：评估WAN环境下系统峰值性能（吞吐量与延迟），涉及不同故障数、负载和批大小场景，与其他协议对比（图3a、3b、3e、3f、3i、3j）。执行文件位于scripts目录（如表4）。

实验（E2）：[无故障时的吞吐量与延迟] [1人时+3计算时]：类似实验（E1），评估LAN环境下系统峰值性能（图3c、3d、3g、3h、3k、3l）。执行文件同名且位于scripts目录。

实验（E3）：[恢复过程] [1人时+1计算时]：评估系统在崩溃故障下的鲁棒性（表2）。切换至Achilles-Recover分支，运行 `python3 runRecover.py --p4 --faults faults`测试初始化时间和恢复时间。

## 6 讨论

### 6.1 响应性与并行性问题

Gupta等人[28]指出了现有TEE辅助BFT协议存在的响应性受限和缺乏并行性问题。为解决这些问题，Gupta等人将容错阈值从𝑛=2𝑓+1降低到3𝑓+1（详见第1节）。然而，Bessani等人[10]表明，放宽容错阈值并非必要，通过一些简单修改即可轻松解决这两个问题。接下来我们介绍这些修改，特别是Achilles中采用的修改。

响应性受限。在TEE辅助BFT协议中，客户端通常需要从共识节点收集𝑓+1个回复以确保交易已提交。然而，若交易仅由𝑓+1个节点的法定人数提交，可能只有一个诚实节点会回复客户端。因此，客户端无法收集足够回复，直到所有诚实节点通过检查点同步提交状态，导致回复响应性受限。

Bessani等人[10]指出，此问题并非TEE组件特有，PBFT[15]和BFT-SMaRt[11]中也存在类似问题，其中交易读取可通过收集𝑛−𝑓个回复优化以避免运行共识[9]。针对该问题有两种简单解决方案：第一，节点提交并回复客户端时，可向其他节点广播决策消息以提醒它们[7,44]；第二，领导者执行交易并将结果包含在区块中，区块提交后任意节点可向客户端发送证书以验证结果。此方法广泛应用于以太坊等区块链[65]。Achilles采用第二种方法，并利用TEE的完整性避免使用证书。

缺乏并行性。采用 equivocation检测[39,68]的TEE辅助BFT协议要求节点串行访问可信组件以验证消息，强制消息序列无间隙[10]。这种串行化禁止了PBFT[15]等协议的并行性。Bessani等人[10]表明，流水线、并发共识实例和面向共识的并行化等技术可缓解并行性问题。Achilles遵循链式BFT协议的链式设计思想，实现线性消息复杂度并支持频繁领导者轮换。区块中批量交易的链式结构（即链接批量交易）已可实现良好的扩展性和性能。我们可通过并发共识实例[27,40,55]进一步并行化Achilles，这将作为未来工作。

### 6.2 动态重配置

Achilles未考虑动态重配置（允许节点随时间动态加入或移除）。尽管BFT共识中的重配置已在先前工作[11,22]中深入探索，但在存在回滚问题的情况下将动态重配置与恢复过程集成对Achilles仍是挑战。这是因为重启节点依赖配置信息确定应向哪些节点发送恢复请求。由于回滚问题，节点可能使用过时的配置信息，可能加入旧节点组处理客户端交易，这可能违反安全性。此外，若重配置发生在恢复期间且部分旧配置节点被移除，重启节点可能无法收集足够恢复响应，违反活性。因此，实现动态重配置同时避免这些安全缺陷需要大量工作，将作为未来工作。

### 6.3 过度故障

在Achilles中，我们假设同时重启的节点不超过𝑓个。若无此假设，系统可能因节点无法通过收集𝑓+1个回复恢复而失去活性。但此限制并非我们工作独有，无稳定存储的无盘CFT协议（如VR[38]和Paxos变体[16,35]）也有相同约束（同时崩溃节点不超过𝑓个）。此外，所有BFT协议均有安全阈值𝑓，攻击者破坏超过𝑓个节点将破坏系统活性/安全性，这对Achilles同样成立。
